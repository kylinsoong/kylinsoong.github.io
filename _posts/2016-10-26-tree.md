---
layout: blog
title:  "数据结构 - 树"
date:   2016-10-26 18:50:12
categories: java
permalink: /tree
author: Kylin Soong
duoshuoid: ksoong2016102601
excerpt: 树, 二叉树, 二叉查找树, AVL 树, 伸展树, B 树, TreeSet 和 TreeMap 的实现
---

* Table of contents
{:toc}

## 基本概念

![Tree Overview]({{ site.baseurl }}/assets/blog/java/tree-overview.png)

* 根(root)
* 边(edge)
* 儿子(child)
* 父亲(parent)
* 一棵树有 N 个节点和 N - 1 条边
* 兄弟(siblings)
* 祖父(grandparent)
* 孙子(grandson)
* 路径(path) - 树中任意两个节点之间只有一条路径
* 深度(depth) - 树中任意两个节点之间路径的长度
* 高(height) - 树中最长的路径
* 祖先(ancestor)
* 后裔(decendant)
* 真祖先(proper ancestor)
* 真后裔(proper decendant)

### 树的实现

~~~
public class TreeNode<T> {
    T element;
    TreeNode<T> firstChild;
    TreeNode<T> nextSibling;
}
~~~

### 树的两种遍历方式

1. 前序遍历(preorder traversal) - 对节点的处理在它的诸儿子节点被处理之前进行
2. 后序遍历(postorder traversal) - 对节点的处理在它的诸儿子节点被处理之后进行

## 二叉树

**二叉树**(binary tree) 是特殊的树 - 树中的每个节点都不能有多于两个的儿子.

![Tree binary tree]({{ site.baseurl }}/assets/blog/java/tree-binary-tree.png)

### 二叉树的实现

~~~
public class BinaryNode<T> {
    T element;
    BinaryNode<T> left;
    BinaryNode<T> right;
}
~~~

### 二叉树的三种遍历方式

1. 前序遍历(preorder traversal) - 对节点的处理在它的诸儿子节点被处理之前进行
2. 中序遍历(inorder traversal) - 处理节点之前先处理左节点，处理节点之后再处理后节点 
3. 后序遍历(postorder traversal) - 对节点的处理在它的诸儿子节点被处理之后进行

### 查找树 ADT - 二叉查找树

#### 定义

* 树中每个节点 X，它的左子树中所有的节点对应的值小于节点 X 的值.
* 二叉查找树的平均深度是 **O(log N)**
* 二叉查找树要求所有节点都能够排序

#### 二叉查找树的实现

~~~
public class BinarySearchTree<T extends Comparable<? super T>> {

    private BinaryNode<T> root;
    
    public BinarySearchTree() {
        this.root = null;
    }
    
    public void makeEmpty() {
        this.root = null;
    }
    
    public boolean isEmpty() {
        return this.root == null ;
    }
    
    public boolean contains(T x) {
        return contains(x, root);
    }
    
    public T findMin() {
        if(isEmpty())
            throw new UnderflowException();
        return findMin(root).element;
    }

    public T findMax() {
        if(isEmpty())
            throw new UnderflowException();
        return findMax(root).element;
    }
    
    public void insert(T x) {
        this.root = insert(x, root);
    }

    public void remove(T x) {
        this.root = remove(x, root);
    }
    
    public void printTree() {
        printTree(root);
    }
}
~~~

##### contains 方法

~~~
    private boolean contains(T x, BinaryNode<T> t) {
        
        if(null == t)
            return false;
        
        int compareResult = x.compareTo(t.element);
        if(compareResult < 0) {
            return contains(x, t.left);
        } else if(compareResult > 0) {
            return contains(x, t.right);
        } else {
            return true;
        }
    }
~~~

##### findMin 方法

~~~
    private BinaryNode<T> findMin(BinaryNode<T> t) {
        
        if(t == null) {
            return null;
        } else if (t.left == null) {
            return t;
        }
        
        return findMin(t.left);
    }
~~~

##### findMax 方法

~~~
    private BinaryNode<T> findMax(BinaryNode<T> t) {
        
        if(t == null) {
            return null;
        } else if(t.right == null) {
            return t;
        }
        
        return findMax(t.right);
    }
~~~

##### insert 方法

~~~
    private BinaryNode<T> insert(T x, BinaryNode<T> t) {
        
        if(null == t)
            return new BinaryNode<>(x, null, null);
        
        int compareResult = x.compareTo(t.element);
        if(compareResult < 0) {
            t.left = insert(x, t.left);
        } else if(compareResult > 0) {
            t.right = insert(x, t.right);
        }

        return t;
    }
~~~

##### remove 方法

~~~
    private BinaryNode<T> remove(T x, BinaryNode<T> t) {
        
        if(null == t)
            return t;
        
        int compareResult = x.compareTo(t.element);
        if(compareResult < 0) {
            t.left = remove(x, t.left);
        } else if (compareResult > 0) {
            t.right = remove(x, t.right);
        } else if(t.left != null && t.right != null) {
            t.element = findMin(t.right).element;
            t.right = remove(t.element, t.right);
        } else {
            t = (t.left != null) ? t.left : t.right;
        }
        
        return t;
    }
~~~

##### printTree 方法

~~~
    private void printTree(BinaryNode<T> t) {
        if(t != null) {
            printTree(t.left);
            System.out.println(t.element);
            printTree(t.right);
        }
    }
~~~

#### 示例

##### 1. 通过 insert 初始化树

本示例通过 insert 初始化树的形状如下

![Binary Search Tree Example 1]({{ site.baseurl }}/assets/blog/java/tree-binary-search-tree-example-1.png)

> 后面示例中不做特别说明都使用本示例中如上所示的树。

~~~
BinarySearchTree<Integer> tree = new BinarySearchTree<Integer>();
tree.insert(6);
tree.insert(2);
tree.insert(1);
tree.insert(4);
tree.insert(3);
tree.insert(8);
~~~

##### 2. 添加新节点

如下图所示，我们向示例 1 中的树添加新节点 5

![Binary Search Tree Example 2]({{ site.baseurl }}/assets/blog/java/tree-binary-search-tree-example-2.png)

~~~
BinarySearchTree<Integer> tree = sample1();
tree.insert(5);
~~~

##### 3. 查找最大和最小节点

基于示例 1 中的树通过如下代码查找最大和最小节点

~~~
BinarySearchTree<Integer> tree = sample1();
System.out.println(tree.findMax());
System.out.println(tree.findMin());
~~~

运行结果输出

~~~
8
1
~~~

##### 4. 查找树中是否包含某节点

基于示例 1 中的树通过如下代码查找树中是否包含某节点

~~~
BinarySearchTree<Integer> tree = sample1();
System.out.println(tree.contains(8));
System.out.println(tree.contains(5));
~~~

运行结果输出

~~~
true
false
~~~

##### 5. 删除只有一个子节点的节点

基于示例 1 中的树的节点 4 只有一个左节点3，本示例演示删除节点4，结果如下图

![Binary Search Tree Example 3]({{ site.baseurl }}/assets/blog/java/tree-binary-search-tree-example-3.png)

~~~
BinarySearchTree<Integer> tree = sample1();
tree.remove(4);
~~~

##### 6. 删除有两个子节点的节点

基于示例 1 中的树的节点 2 只有一个左节点 1 和一个右节点 4，本示例演示删除节点 2，结果如下图

![Binary Search Tree Example 4]({{ site.baseurl }}/assets/blog/java/tree-binary-search-tree-example-4.png)

~~~
BinarySearchTree<Integer> tree = sample1();
tree.remove(2);
~~~

> NOTE: 删除有两个子节点的节点的策略是用该节点右子树中最小的节点替换该节点

##### 7. 发生多次替换的复杂节点删除

如下左图，删除树中节点 2，节点 2 右子树中最小的节点为 3，且 节点 3 有右子树

![Binary Search Tree Example 5]({{ site.baseurl }}/assets/blog/java/tree-binary-search-tree-example-5.png)

~~~
BinarySearchTree<Integer> tree = sample2();
tree.remove(2); 
~~~

> NOTE: 如上删除过程发生了两次节点替换：节点 2 替换 节点 2 右子树最小的节点 3；节点 3 替换 节点 3 右子树最小的节点 4.

### AVL 树
