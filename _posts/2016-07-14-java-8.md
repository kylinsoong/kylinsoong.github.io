---
layout: blog
title:  "Java 8 new features study notes"
date:   2016-07-14 18:50:12
categories: java
permalink: /java-8
author: Kylin Soong
duoshuoid: ksoong2016071402
excerpt: Lambda Expressions, @FunctionalInterface
---

* Table of contents
{:toc}

## Overview

### What made big change occur in java 8

1. Simplifying - write programs more easily—instead of writing verbose code
2. Parallelism - commodity CPUs have become multicore, fork/join framework in java 7 is too difficult.

### Functions in Java

**First-class values Vs second-class citizens** - Only first-class values be passed around during program execution

* Passing code example - Find Hidden Files

~~~
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
~~~

### Streams

* expose on collections
* Parallel computations on data

## Behavior parameterization

In this section, we use a example to explain what's Passing code with behavior parameterization and how to make code evolvable.

### Prior to Java 8

#### 1. filtering apples by color

~~~
public static List<Apple> filterApplesByColor(List<Apple> inventory, String color) {
    List<Apple> result = new ArrayList<>();
    for(Apple apple: inventory){
        if(apple.getColor().equals(color)){
            result.add(apple);
        }
    }
    return result;
}
~~~

#### 2. filtering apples by weight

~~~
public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight) {
    List<Apple> result = new ArrayList<>();
    for(Apple apple: inventory){
        if(apple.getWeight() > weight){
            result.add(apple);
        }
    }
    return result;
}
~~~

#### 3. filtering with every attribute you can think of

~~~
public static List<Apple> filterApples(List<Apple> inventory, String color, int weight, boolean flag){
    List<Apple> result = new ArrayList<>();
    for(Apple apple: inventory){
        if((flag && apple.getColor().equals(color)) || (!flag && apple.getWeight() > weight)){
            result.add(apple);
        }
    }
    return result;
}
~~~

### Behavior parameterization

First define an interface to model the selection criteria:

~~~
public interface ApplePredicate {
    public boolean predicate(Apple apple);
}
~~~

Different strategies for selecting an Apple

~~~
static class AppleWeightPredicate implements ApplePredicate {
    public boolean predicate(Apple apple) {
        return apple.getWeight() > 150;
    }
}
    
static class AppleColorPredicate implements ApplePredicate {
    public boolean predicate(Apple apple) {
        return "green".equals(apple.getColor());
    }
}
~~~

#### 4. filtering by abstract criteria

~~~
public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p) {
    List<Apple> result = new ArrayList<>();
    for(Apple apple : inventory){
        if(p.predicate(apple)){
            result.add(apple);
        }
    }
    return result;
}
~~~

### Anonymous classes

* don’t have a name
* let you declare and instantiate a class at the same time
* create ad hoc implementations

#### 5. using an anonymous class

~~~
List<Apple> greenApples = filterApples(inventory, new ApplePredicate(){
    public boolean predicate(Apple apple) {
        return "green".equals(apple.getColor());
    }});
~~~

#### 6. using a lambda expression

~~~
List<Apple> greenApples = filterApples(inventory, (Apple apple) -> "green".equals(apple.getColor()));
~~~

#### 7. abstracting over List type

~~~
public interface Predicate<T> {
    boolean predicate(T t);
}
    
public static <T> List<T> filter(List<T> list, Predicate<T> p) {
    List<T> result = new ArrayList<>();
    for(T e : list){
        if(p.predicate(e)){
            result.add(e);
        }
    }
    return result;
}

List<Apple> greenApples = filter(inventory, (Apple apple) -> "green".equals(apple.getColor()));
~~~

### Real-world examples

#### Sorting with a Comparator

~~~
List<Apple> inventory = Arrays.asList(new Apple(80,"green"), new Apple(155, "green"), new Apple(120, "red"));
        
inventory.sort(new Comparator<Apple>(){
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }});
        
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
~~~

#### Executing a block of code with Runnable

~~~
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
    // do something
}));
~~~

#### GUI event handling

~~~
Button button = new Button("Send");
button.setOnAction((ActionEvent event) -> label.setText("Sent!!"));
~~~

## Lambda expressions

### What's Lambda expressions

The Definition of Lambda:

1. **Anonymous** - doesn’t have an explicit name
2. **Function** - a lambda isn’t associated with a particular class like a method is, a lambda has a list of parameters, a body, a return type, and a possible list of exceptions that can be thrown
3. **Passed around** - A lambda expression can be passed as argument to a method or stored in a variable.
4. **Concise** - You don’t need to write a lot of boilerplate like you do for anonymous classes.

The basic syntax of Lambda

~~~
(parameters) -> expression
~~~

or 

~~~
(parameters) -> { statements; }
~~~

### Where and how to use lambdas

* use a lambda expression in the context of a functional interface.

#### Functional interface and Function descriptor

* A functional interface is an interface that specifies exactly one abstract method.
* @FunctionalInterface

### Functional interfaces

1. Predicate - defines an abstract method named test that accepts an object of generic type T and returns a boolean 
2. Consumer - defines an abstract method named accept that takes an object of generic type T and returns no result (void).
3. Function - defines an abstract method named apply that takes an object of generic type T as input and returns an object of generic type R.

> NOTE: boxing/unboxing/autoboxing - boxing means convert a primitive type into a corresponding reference type, the opposite approach called unboxing. Java also has an autoboxing mechanism that boxing and unboxing operations are done automatically. Boxed values use more memory and comes with a performance cost, Java 8 brings addtional functional interfaces(IntPredicate, DoublePredicate, ToIntFunction<T>, IntTo-DoubleFunction, etc) to avoid autoboxing.

### Lambda Type

* Type checking - deduce the type of lambda from the context in which the lambda is used.
* Target typing 
* Type inference

### Method references

~~~
List<Apple> inventory = Arrays.asList(new Apple(80,"green"), new Apple(155, "green"), new Apple(120, "red"));
inventory.sort(comparing(Apple::getWeight));
System.out.println(inventory);
~~~

Constructor references:

~~~
BiFunction<Integer, String, Apple> function = Apple::new;
System.out.println(function.apply(100, "red"));
~~~




